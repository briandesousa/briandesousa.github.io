{"componentChunkName":"component---src-templates-blog-post-js","path":"/using-node-11-worker-threads-with-rxjs-observable/","result":{"data":{"site":{"siteMetadata":{"title":"BrianDeSousa.net"}},"markdownRemark":{"id":"5a300c7c-fee2-5b94-9801-bed47ce6ffd9","excerpt":"Node.js worker_threads + Observables With the release of Node 11.7, the worker_threads module becomes a standard feature and is no longer hidden behind the…","html":"<p><img src=\"images/worker-thread-observable-1.png\" alt=\"Node.js worker_threads + Observables\"></p>\n<p>With the release of Node 11.7, the worker_threads module becomes a standard feature and is no longer hidden behind the <code class=\"language-text\">--experimental-worker</code> switch. The worker_threads module allows developers to run JavaScript asynchronously in light-weight, isolated threads contained within the main Node process. This article will be focusing on how use worker threads to execute a task asynchronously and stream data from that task back to the rest of your Node application using RxJS Observables.</p>\n<p>Before we get started, if you want to learn more about worker threads and why you might want to use them, I would recommend reading <a href=\"https://blog.logrocket.com/node-js-multithreading-what-are-worker-threads-and-why-do-they-matter-48ab102f8b10\">Node.js multithreading: What are Worker Threads and why do they matter?</a> by <a href=\"https://blog.logrocket.com/@gimenete\">Alberto Gimeno.</a> Alberto has done a fantastic job explaining the purpose of the worker_thread module, provided some solid examples of where it makes sense to use it as well as demonstrated some alternate ways to build a multi-threaded Node app.</p>\n<h2>What are we building?</h2>\n<p>We are going to be building a simple Node app that creates a worker thread running a simulated long-running task that reports status back at regular intervals until it completes or until time runs out. The worker thread will be wrapped in an RxJS Observable so that the rest of the application can stream messages returned from the worker thread using the powerful RxJS library.</p>\n<p><strong>If you want to jump ahead and see the final solution, you can see it out on GitHub at</strong> <strong><a href=\"https://github.com/briandesousa/node-worker-thread-rxjs\">briandesousa/node-worker-thread-rxjs</a>****.</strong></p>\n<h2>Setting up your environment</h2>\n<p>The first thing we need to do is ensure our environment is ready to go:</p>\n<ol>\n<li>Install Node 11.7.0+</li>\n<li>Use <code class=\"language-text\">npm init</code> to initialize a new NPM package</li>\n<li>Add a simple start script to the package.json to start the app: <code class=\"language-text\">node node-parent-thread-rxjs.js</code></li>\n<li>Install the RxJS package with <code class=\"language-text\">npm install -s rxjs</code></li>\n<li>Create node-parent-thread-rxjs.js which will contain code running on the main thread</li>\n<li>Create node-worker-thread-rxjs.js which will contain the implementation of the long-running task running on a separate thread</li>\n</ol>\n<h2>Creating the worker thread</h2>\n<p>The worker thread has the logic to simulate a long-running task:</p>\n<p>[gist <a href=\"https://gist.github.com/briandesousa/28949fe67a47362b1391bcd136debc0e\">https://gist.github.com/briandesousa/28949fe67a47362b1391bcd136debc0e</a> /]</p>\n<p>Let's break this script down a bit:</p>\n<ul>\n<li>We use <code class=\"language-text\">parentPort</code> from the <code class=\"language-text\">worker_threads</code> modules to communicate back to the parent thread at 3 different points:\n<ul>\n<li>before the task begins</li>\n<li>while the task is running (within the do while loop) to provide status back to the parent thread</li>\n<li>when the task completes</li>\n</ul>\n</li>\n<li>We use <code class=\"language-text\">workerData</code> from the <code class=\"language-text\">worker_threads</code> module to pass in a time limit for how long (in seconds) the task should run for. The task completes when this time limit is reached (line 19).</li>\n</ul>\n<p>This worker thread doesn't do anything particularly useful but it does demonstrate how a thread might receive instructions from its parent and stream multiple updates back to its parent.</p>\n<h2>Creating the parent thread</h2>\n<p>The parent thread has the following responsibilities:</p>\n<ul>\n<li>Start the worker thread, specifying how long the worker thread should run for. We will call this WORKER_TIME.</li>\n<li>Receiving updates from the worker thread in an observable stream</li>\n<li>Exit the application if the worker thread takes too long. We will call this MAX_WAIT_TIME.</li>\n</ul>\n<p><a href=\"https://gist.github.com/briandesousa/28f1c667e6c9b22aad5aaaa9a6dd36b7\">https://gist.github.com/briandesousa/28f1c667e6c9b22aad5aaaa9a6dd36b7</a></p>\n<p>There is a lot going on here. Let's focus on the <code class=\"language-text\">runTask()</code> function first:</p>\n<ul>\n<li>We use <code class=\"language-text\">Observerable.create()</code> from the <code class=\"language-text\">rxjs</code> package to create a new observable. This observable creates an instance of the worker thread and passes some data in.</li>\n<li>We map events output from the worker thread to the appropriate functions on the <a href=\"http://reactivex.io/rxjs/class/es6/MiscJSDoc.js~ObserverDoc.html\">Observer</a> interface:\n<ul>\n<li><code class=\"language-text\">message</code> events are returned as normal values pushed to the subscriber through <code class=\"language-text\">Observer.next()</code></li>\n<li><code class=\"language-text\">error</code> events are mapped to <code class=\"language-text\">Observer.error()</code></li>\n<li>when an <code class=\"language-text\">exit</code> message is received, we check the message to determine why the worker thread exited:\n<ul>\n<li>if a non-zero value is returned, then we know something went wrong and map the result to <code class=\"language-text\">Observer.error()</code></li>\n<li>if zero is returned, we call a callback function to notify the application that the task was completed on time, we send one final special COMPLETE_SIGNAL value and then we complete the observable with <code class=\"language-text\">Observer.complete()</code></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>The <code class=\"language-text\">runTask()</code> doesn't have a very descriptive name however you can now see that it encapsulates the mapping logic between worker thread events and the Observable interface.</p>\n<p>Next, let's look at the at the <code class=\"language-text\">main()</code> function:</p>\n<ul>\n<li>We create the observable by calling <code class=\"language-text\">runTask()</code>. We pass in a simple callback that sets the <code class=\"language-text\">completedOnTime</code> flag to true so that we can report the reason why the observable completed.\n<ul>\n<li>Note that the observable we just created is a <a href=\"http://reactivex.io/documentation/observable.html\">cold observable</a>. It creates the worker thread and starts emitting events only once it has been subscribed to.</li>\n</ul>\n</li>\n<li>We pipe some RxJS operator functions into the observable:\n<ul>\n<li><code class=\"language-text\">takeWhile()</code> to stop the stream when the special COMPLETE_SIGNAL value is received</li>\n<li><code class=\"language-text\">takeUntil()</code> to stop the stream when time has run out</li>\n</ul>\n</li>\n<li>We subscribe to the observable and log any values or errors that are received to the console. When the observable completes, we log the reason why it completed. If the reason is because we ran out of time, then we forcefully exit the application with <code class=\"language-text\">process.exit(0)</code>.</li>\n</ul>\n<h2>Running the solution</h2>\n<p>Run the solution with your <code class=\"language-text\">npm start</code> command. Assuming MAX_WAIT_TIME is still set to 3 and WORKER_TIME is set to 10, you will see the following output:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Node multi-threading demo using worker_threads module in Node 11.7.0 [Main] Starting worker from process 4764 [Main] worker says: starting heavy duty work from process 4764 that will take 10s to complete [Main] worker says: heavy duty work in progress...1s [Main] worker says: heavy duty work in progress...2s [Main] worker says: heavy duty work in progress...3s [Main] worker could not complete its work in the allowed 3s, exiting Node process</code></pre></div>\n<p>The worker thread started to do its work, but after 3 seconds, the app signaled to stop the stream. The main process was forcefully exited along with the worker thread before it had a chance to complete its task.</p>\n<p>You can also try adjusting the solution to see what happens when:</p>\n<ul>\n<li>WORKER_TIME is less than MAX_WAIT_TIME</li>\n<li>multiple worker threads are spawned from the parent thread by calling <code class=\"language-text\">runTask()</code> multiple times and creating multiple observables with different settings</li>\n</ul>\n<h2>Wrap up</h2>\n<p>We have only just scratched the surface of what is possible when you combine the streaming power and beauty of RxJS Observables with the worker_threads module. Happy threading!</p>\n<p>Check out the full solution on GitHub at <a href=\"https://github.com/briandesousa/node-worker-thread-rxjs\">briandesousa/node-worker-thread-rxjs</a>.</p>","frontmatter":{"title":"Using Node 11.7 Worker Threads with RxJS Observable","date":"February 16, 2019","description":null}},"previous":{"fields":{"slug":"/case-sensitive-import-statements-in-typescript/"},"frontmatter":{"title":"Case-sensitive import statements in TypeScript"}},"next":null},"pageContext":{"id":"5a300c7c-fee2-5b94-9801-bed47ce6ffd9","previousPostId":"314a97c9-b67b-5193-bafe-21c7737f0448","nextPostId":null}},"staticQueryHashes":["2841359383","3257411868"],"slicesMap":{}}